書名: 魔法学概论
URL: https://www.esjzone.cc/detail/1652250485.html
類型: 原創
作者: UltimateLambda
更新日期: 2022-12-22 

使用的備份工具:
https://github.com/ZALin/ESJ-novel-backup




并非小说, 大概可能是随笔, 小品, 散文, 怪谈之混合罢. 虽然标题是魔法学概论, 但更近于魔术学 (TYPE-MOON) 概论. 应该会有许多程式语言写成的东西, 但这是不可避免的. 作者认为, 作为精确语言, 程式语言不仅可以用来表达计算, 也能够表达一般的思想. 程序, 是供人阅读的, 附带给机器运行.个人主页: https://alpha-beta-eta.github.io/


前言 
[序言] by ultimatelambda

科幻作家克拉克曾经说过, 任何技术在不懂的人眼中都无异于魔法. 埃及人建造金字塔的技术, 是古代魔法的一个实例.
魔法虽然抽象, 却是很具体的东西. 如果你们觉得对使魔下令帮助你们写作业算是魔法的话, 那就全然误解了魔法的实质. 我指的是, 使魔压根就没有办法帮助你们写作业, 因为这个命令不够具体.
魔法的核心是抽象, 这与数学类似. 在物理中, 串联一万个放大器是荒谬的. 然而, 在魔法学中, 串联一万个魔法是相当合理的. 这是魔法相当与众不同的特点. 换句话说, 如果在现实世界中抽象是一种原理的话, 在魔法世界中, 抽象就是一种法则. 它全然就是精确的, 而不是在某种限度内近似精确的.
魔法学最重要的分支是程序设计学与魔法语言学. 前者的重要性历来被人们忽视, 而后者在魔法学中, 出于历史原因, 相当小众. 不过, 本书主要就是关于这两个领域的.
程序设计学被人们忽视的原因其实很简单, 因为写程序太简单了. 任何人都能写程序, 但不是任何人都是魔法师. 许多想成为魔法师但并不是魔法师的人们写了许多关于魔法的垃圾, 他们经常向希望学习魔法的人灌输一种错误的想法, 即要成为魔法师必须精通数据结构和算法. 数据结构和算法当然是重要的, 但并不是最重要的, 而且不是首先应该学习的. 一个新人, 最开始应该学习的东西, 应该是如何组织他的程序.
魔法语言学小众的原因其实也相当简单, 那就是这个学科有很长时间的混沌期. 那时的研究者完全不知道在做些什么, 其中偶尔有些非常聪明的人, 是他们的专著逐渐塑造了现代的魔法语言学, 那些作品至今仍有阅读的价值. 然而, 的确因为那个很长的混沌期, 使得许多人, 甚至是魔法大师, 也对于魔法语言学充满了偏见. 比如, 一些门外汉以为句法学是魔法语言学的核心, 魔法语言学不外乎是关于句法分析的学科. 魔法语言学的研究者经常怀有令人讶异的傲慢, 或许正是与这些人有关, 但这也使得魔法语言学至今很小众.
我的书试图同时讨论这两个分支学科, 并希望将它们安于适当的位置. 同时, 我也希望我的作品能够拥有永恒的价值, 而不像许多人评论道的那样, "魔法是一种每年翻新的时尚". 

第一章 编程的基础
读取-求值-输出循环 
[读取-求值-输出循环] by ultimatelambda

Read-Evaluate-Print Loop, 一般缩写为REPL, 直译就是读取-求值-输出循环, 是许多Scheme实现提供的一种模式. 它是绝佳的魔法试验场所, 也是学习魔法的最好方式. 其中, 你输入一个表达式, 系统就会读入它, (将其转换为句法对象,) 对它进行求值, 然后将结果直接地输出在下方, 并继续等待新的输入. 琢磨REPL的输入和输出, 是任何魔法学徒都必须进行的修炼.
鉴于REPL的形式因实现而异, 我们采取以下记法上的约定: 输入以>作为提示符, 输出直接显示在下一行. 请看以下示例:

它的意思, 或许你已经猜到了, 它表示42这个表达式的值是42. 

字面量 
[字面量] by ultimatelambda

一些种类的表达式的值即它们的字面本身 (虽然读者应该注意到这个说法有所简化), 所以我们将其称为字面量.
常见的字面量有数字, 布尔和字符串等.

Scheme的实现大都支持分数 (可以视为整数的序对) 和复数 (可以视为实数的序对). 至于浮点数 (floating number) 的种种, 我们绝不打算深入涉及, 因为它偏离了我们的目的, 但这也并不困难.
Scheme使用#t表示真(true), #f表示假(false).
字符串从句法上看是用两个"括起来的字符序列.
历史注记: hello world程序是Unix文化中典型的第一个程序或者测试用程序, 但在Lisp文化 (Scheme是Lisp的一个现代方言) 中则并非如此. 有意思的是, 关于Unix文化的重要书籍The New Hacker's Dictionary (新黑客词典) 是基于反映了Lisp文化的书籍The Hacker's Dictionary (黑客词典) 篡改而成的, 而The Hacker's Dictionary的原稿源于Guy Steele在角落里发现的jargon file (行话文件). jargon file主要是作搞笑之用, 它反映了第一代黑客的原始风貌, 这与现在大众文化中的黑客的概念非常不同. 

变量 
[变量] by ultimatelambda

变量在字面上是符号 (或者更确切地说是标识符), 但它不代表字面, 而是引用与其关联的值. 这与数学的实践类似, 但数学文献经常混淆符号和变量, 然而在Scheme中这两者有着句法上的区别, 虽然暂时我们还不会引入符号.
我们可以用define形式将一个符号和一个值关联起来, 这就是"起名字", 一种最基本的抽象形式. 俗话有云, 如果你知道一个精灵的真名 (true name), 那么你也就能够操纵它.

注意: 在Scheme中, 过程, 或者说函数, 也是值, 或者说是可以操纵的对象. 同样地, 我们可以使用符号去引用一个过程, 但它的表示, 是因实现而定的. 这里面有很多原因, 之后我们会解释.

+自然与一个表示数字加法的过程相关联. 这是我使用的实现 (Chez Scheme) 输出的样式. 

过程应用 
[过程应用] by ultimatelambda

过程应用 (procedure application) 的意思就是将过程应用于具体的参数上去, 而过程是函数的近义词.
一般来说我们并不区分过程和函数这两个术语, 但现在我们略微讨论一下. 现代数学意义上的函数是外延性的, 也就是说, 函数只是输入和输出的对应, 同算术, 算法和几何图形没有直接的联系. 即便一个函数由某个公式给出, 数学家也仅是将其当作序对的集合 (不过, 一个函数的资料一般还包括它的domain和codomain). 程序设计中出现的过程和函数是不同的, 因为它不仅仅是一种对应关系, 还蕴含着如何从输入计算得到输出的规则方法, 也就是说, 它更具内涵性. 在历史上, 函数的概念有着很长的发展历程, 但自从Dirichlet之后, 外延性的观念就逐渐占上风了, 并到现在完全主宰了数学领域. 但是, 随着魔法学的兴起, 内涵性的观念重新得到重视, 并且与之相关的lambda calculus等理论也得到极大发展.
传统上, 数学中函数应用的句法是多种多样的, 比如有中缀记号, 主要用于加减乘除, 前缀记号, 主要用于人们自己定义的函数, 还有一些角标记号等等. 但是, Scheme中只有一种过程应用的记号, 那就是"全加括号的前缀记号". 虽然最开始许多人会因为数学实践中养成的习惯对这种记号很不适应, 但是多加使用之后就会发现它的确是一种更加一致与方便的记号.

(remainder自然是取余数的过程, quotient自然是取商的过程.) 

表示过程的记号 
[表示过程的记号] by ultimatelambda

显然, 我们需要一种记号来表示过程. Scheme中的这个记号一般被称为lambda表达式, 它的式样与名字, 自然是源于lambda calculus.
lambda表达式的一般句法是(lambda (<var>*) <exp>). 使用尖括号括起来的符号表示一个句法范畴, 当一个句法里出现句法范畴时, 它意在被该句法范畴的一个元素 (或者说一个实例) 所替代. 这里我们用<var>表示所有符号构成的句法范畴, <exp>表示的是所有表达式构成的句法范畴. 虽然表达式是什么样的东西我们还没有定义, 但直到我们开始讨论魔法语言学之前, 我们都认为这个概念从直觉上是可以理解的. *是Kleene star, 它跟在一个句法范畴后面, 表示零个至任意有限多个皆可.
以上的说明有些复杂, 还是举简单的例子来得容易.

我们可以看到, 对于(lambda (x) (* x x))求值的结果是一个过程. 应用这个过程, 它的句法与之前我们见过的完全一致, 比如, 于分数1/2上, 就得到了1/4. 显然, 这个过程的意思是平方, 任何学过数学的人都能明白, x是过程的(形式)参数, (* x x)是过程的体. (之所以称这个参数是形式的, 是因为它只是一个占位符, 不具有实际的含义.)
这个lambda表达式的数学记号的对应物是

不过, 或许"令f(x)=x*x"是人们更熟悉的说法, 但是读者应该注意到, 函数不需要拥有一个名字, 这是它外在的东西.
这个记号的优点在于用它表示泛函 (functional, 这里我们指以函数为输入或输出的函数) 时, 不会显得凌乱, 反而特别规整, 比如看以下这个例子.

这个例子乍看上去非常复杂, 但是实际上非常简单, 所以我们要分成几个步骤看待它.
首先, 第一个值得注意的部分是

它先接受两个参数f和g, 这两个参数的名字实际上已经暗示了它们应该是函数, 然后返回一个函数, 它接受一个参数x, 返回(f (g x)). 对数学略知一二的读者想必已经明白这个过程表达的是函数的复合之意.
接着, 将函数的复合应用于两个实际的函数, 一个是平方, 一个是加一.

这个函数应用的结果是一个函数, 它先给参数加上一, 接着再进行平方操作.
最后, 我们将这个函数应用于实际的参数3.

就得到了结果16. 

定义 
[定义] by ultimatelambda

我们之前已经见过定义了, 它也能直接地运用于过程.

我们曾说"起名字"是最基本的抽象方式, 那么什么是抽象呢?
抽象有两个基本的方面, 一个方面是从各种东西中寻找共同的模式, 另一个方面是将许多概念组合成一个概念, 在思考这个概念时, 我们从整体出发, 而忽略次要的细节.
实际上, 名是提示我们概念的整体性质的助记符, 所以起名字是最基本的抽象方式.
而且, 当我们寻找到共同的模式时, 我们也往往会忍不住给它起一个名字. 然后, 我们将这个名字所蕴含的概念用于简化它所能应用的一切事物.

以下是一则典型的例子, 或许读者应该咀嚼一小会儿.

为了避免误解, 我们应该指出, 定义的次序在某种程度上具有随意性, 比如这里pi, square和area的定义不论怎样排列都不会影响接下来(area 5)的结果. 这种自由, 在某种程度上, 可以用来提高可读性. 可读性是程序最重要的方面, 因为程序是供人阅读的.
这里area的定义基于pi和square, 这是很低矮的抽象之塔. 当然, 抽象的塔也可以搭得很高很高. 这其中的关键在于, 有的抽象仅仅是功能性的增强, 而有的抽象则在概念上提升了抽象的层次. 也就是说, 它提供了一种屏障, 让人们在思考这层抽象时没有必要思考在它之下的抽象. 这种抽象层次的划分是最朴素也最强大的控制复杂度的手段, 任何实际的工程学和抽象的工程学都离不开它. 以我之见, 魔法的许多方面是工程学, 而且是最纯粹的工程学, 因为它常常无需考虑现实的代价, 而仅仅只需要人能够想出来而已.
注记: 鉴于过程的定义经常出现, Scheme中提供了一种简化但等效的句法用于定义过程. (简化而等效的句法一般被称为句法糖.)

以之前上面的例子为例, 通过这个句法糖, 它可以写成如上形式. 

条件分支 
[条件分支] by ultimatelambda

条件分支表达某种形式的选择.
想一下我们在数学中是如何定义一个实数的绝对值的.

我们可以直接地将其转换为一个Scheme定义.

这里牵扯到一个if表达式, 它的一般句法形式为(if <exp> <exp> <exp>). if表达式的语义是这样的, 它先对于其第一个句法参数求值, 若为真, 则对于第二个句法参数求值, 并且整个if表达式的值就是该求值的结果, 若为假, 则对于第三个句法参数求值, 并且整个if表达式的值就是该求值的结果.
读者应该注意到, if不是一个函数, 因为它不会对它的每个参数都求值, 而是根据对于第一个参数求值的结果, 选择第二个参数和第三个参数其中一个进行求值.
Scheme中还有一个非常常用的条件分支表达式, 名为cond.
其一般的句法形式为(cond (<exp> <exp>) ... (else <exp>)).
为了透明性, 我们应该对于省略号的意图做说明, 它表示前一个子句法形式出现零个至任意有限多个, 也就是说, 它和Kleene star其实是一样的, 只是看起来不同罢了, cond的句法形式也可以表达为(cond (<exp> <exp>)* (else <exp>)).
cond的语义十分简单, 它先对于第一个表达式对的第一个句法参数求值, 若为真, 则对于该对的第二个句法参数求值, 并且将其作为整个cond表达式的值 (剩下的就不会求值了), 若为假, 则将注意力转移到第二个表达式对, 如法炮制. 另外, else在cond的上下文中被视为真, 并且只能出现在最后一个表达式对中. else也可以不出现, 但若直至最后一个对仍然无法确定cond的值的话, 该表达式的值是未刻画的, 因实现而异. 依赖于这种特定实现细节的程序是完全丑陋的, 请读者不要写出丑陋的程序.
实际上, 在绝大部分Scheme实现中, cond表达式会被规约为等价的if表达式.
以下是数学中符号函数的例子.

其意思, 想必已经很明了了.
注记: Scheme将所有不等于#f的值视为真. 这个设计在某种意义上还是非常合理的, 但魔法语言学家肯定会拿出一堆理由反对它. 

and, or, not 
[and, or, not] by ultimatelambda

Scheme中的「and, or, not」对应于「与, 或, 非」的逻辑概念, 但有一些细节值得讨论.
这其中最简单的是not, 它是一个函数. 其接受一个任意的值作为参数. 如果该值为真, 则返回#f; 如果该值为假, 则返回#t.

and和or不是函数, 因为对于and和or表达式的求值遵循短路规则.

and和or表达式都具有不定数目的句法参数, 每个句法参数都是一个表达式. (and)的值等于#t, (or)的值等于#f. 当and和or表达式只具有一个句法参数时, 该句法参数的值就是and或or表达式的值. 当它们具有大于一个的句法参数时, 它们都先对于其第一个句法参数求值. 对于and表达式而言, 这个值为#f的话, 就不需要再对于其后的表达式求值了, 因为不论其后的值如何, 整个and表达式的值都应该是#f, 所以此时and表达式会立即返回#f这个值, 否则的话, 也就是这个值为真的情况, and表达式就不再考虑这个句法参数了, 因为它对于and表达式的值不会有影响了, 转而对于下一个句法参数求值. 对于or表达式而言, 这个值为真的话, 那么整个or表达式的值就应该为真, 所以or表达式立即返回这个值, 否则的话, 也就是这个值为#f的情况, or表达式就不再考虑这个句法参数了, 因为它对于or表达式的值不会有影响了, 转而对于下一个句法参数求值. 以上是短路求值的想法, 但值得说明的是, 短路还是不短路将对于语义产生影响, 因为对于表达式的求值可能不终止, 或是对于表达式的求值会产生副作用.
文字的说明或许有些烦闷, 我们将展示一些求值的逐步过程. 以后读者遇到复杂的表达式时, 也应该采取类似的方法来帮助理解.

根据短路的and和or, abs函数也可以按照如下方式定义.

虽然这被视为一种技巧, 但我们将此视为丑陋的, 所以永远不会使用它. 

递归定义 
[递归定义] by ultimatelambda

递归定义指的是在定义中(直接或间接地)引用自身的定义. 乍看上去, 递归是一种很不合理的东西, 但实际上却很简单. 我们将用许多例子来刻画递归, 这些例子将反复出现.

第一个例子是阶乘, 它的定义是众所周知的.

我们可以将其直接地翻译为Scheme过程.


第二个例子是Fibonacci数列, 它的每一项, 可以通过简单的递归关系式确定.

同样地, 将其翻译为Scheme过程是轻而易举的.


第三个例子是最大公因数 (Euclid算法).

Euclid算法在终止时能够给出正确的结果, 仰赖于以下事实.

Euclid算法必然能够在有限步骤内终止, 是显然的, 因为根据余数的定义, 它小于除数b. 最粗略的估计告诉我们过程gcd最多进行b步, 一个更好的上界估计可以参看Lamé定理, 有趣的是, 它里面出现了Fibonacci数列.

第四个例子是一个互递归的例子. even?判断一个自然数是否是偶数, odd?判断一个自然数是否是奇数.

 

局部定义 
[局部定义] by ultimatelambda

现在我们引入局部定义, 这将进一步增强我们的表达能力.

首先我们引入let形式, 它的一般句法是(let ((<var> <exp>) ...) <exp>). 而其语义, 可以将其视为句法糖来解释. (let ((x0 e0) ...) body)就等价于((lambda (x0 ...) body) e0 ...).
现在我们给出一个简单的例子.

我们看到, let引入的绑定将顶层的绑定覆盖, 所以(let ((x 2)) (* x x))的值是4, 但是绑定不是赋值, 它不会修改外部的绑定, 所以当我们在REPL中对x求值时, 仍然得到0.

接着我们引入let*形式, 它和let有些类似, 实际上let*可以基于let定义.
let形式对于求值的顺序没有任何保证, 虽然现在看来它几乎不会造成任何问题, 因为我们还没有引入副作用. (let* ((x0 e0) (x1 e1) ...) body)等价于(let ((x0 e0)) (let* ((x1 e1) ...) body)), 而(let* () body)就等价于(let () body). 这使得let*具有明确的求值顺序, 即自左往右, 并且它逐次进行绑定.
现在我们给出一个简单的例子.

如果把这里的let*换成let, 则会产生异常, 因为lambda表达式的形式参数应该是互不相同的.

let和let*的语义很容易理解, letrec的语义则不太容易了. 但是, 如果我们仅仅将letrec用于引入(互)递归的过程, 则不会造成什么困难, 现在我们就给出一个例子.

letrec和let不同的是, 它的各右支可以引用左侧的变量 (但是有一定的限制, 不过在只使用letrec引入递归的过程的情况下, 没有什么问题).

最后, 我们引入lambda内部的define, 它的作用范围仅限于lambda表达式的体.

这是一个稍微复杂一点的例子, sqrt是一个利用迭代法求平方根的过程. 数学中的迭代法的大意是我们先给一个猜测值, 看它是否足够好, 如果不够好, 则改进它, 如此反复循环, 直至得到满意的值.

这是迭代法求平方根的依据.

练习. 试说明, 以下过程也能正确计算Fibonacci数列的值, 也就是说, 对于每个自然数n, (fib-iter n)的值等于(fib n)的值.

注记: 鉴于迭代 (不是迭代法) 这种模式经常出现, Scheme提供一种被称为"命名let"的句法糖, 比如说上面的fib-iter就可以改写为以下样式.
 

高阶过程 
[高阶过程] by ultimatelambda

高阶过程指的是参数或者返回值是过程的过程. 我们当然已经看过这样的例子了, 即函数复合.

我们给这个过程取了个名字compose.
高阶过程之所以是必要的, 在于如果没有它们, 诸多概念压根就无法表达.
一个最基本的例子是求和记号, 我们将其翻译成直接的Scheme过程.

另一个非常基本的例子是以下的power过程.

((power n) f)的返回值是一个过程, 它就相当于将n个f复合在一起的函数.
练习. 以下表达式的值是多少?
 

计算行为 
[计算行为] by ultimatelambda


尽管在形式上, fact和gcd都是递归的, 但是当fact的输入n大于0时, 在得出(fact (- n 1))的结果之后, Scheme还必须"记住"将该值乘上n, fact的输入越大, 中间积累的记忆也就越多, 反观gcd, 如果b不是0, (gcd b (remainder a b))的结果直接就是(gcd a b)的结果, 记忆不会随着输入规模的增大而增长. 我们称像fact这样的过程呈现了递归计算行为, 而gcd这样的过程呈现了迭代计算行为.
注记: 虽然从原则上gcd描述了一种迭代式计算, 但语言的实现仍有可能指导机器产生递归计算行为.
练习. 观察以下过程.

参数k可以理解为fact求值过程中的记忆, 而(fact-cps n (lambda (v) v))的值就等于(fact n).
请证明对于以下过程fact-iter, 我们有(fact-iter n 1)的值等于(fact n).
并且, 试说明fact-iter和fact-cps之间的联系.

提示: cps是延续传递风格 (continuation-passing style) 的缩写, 延续是对于剩余的计算 (即我们之前所说的"记忆") 的抽象, fact-cps的参数k就代表延续. 

编程基础习题一 
[编程基础习题一] by ultimatelambda

学习什么不进行练习是不可能的, 学习编程也不例外, 所以我准备了许多有意思的习题. 在准备这些习题的时候, 我想到的是Halmos的Linear Algebra Problem Book这本书, 它也是我编制习题的标准. 也就是说, 要从一般的原理出发, 而不是从其对于其他领域的应用出发.

 

第二章 列表处理
序对 
[序对] by ultimatelambda

一个序对将恰好两个概念组合在一起. 并且, 给定一个序对, 我们可以将两个概念分离出来. 从此方面理解, 序对是最基本的组合手段.
Scheme提供了三个和序对相关的过程. cons用来构造序对, car是第一投影, cdr是第二投影. car和cdr这两个名字的由来是历史性的, 读者不必清楚.

以上交互刻画了序对最基本的用法.
Scheme输出序对的方式有些微妙.

当序对串起来的时候, 只有最后两个元素之间用.分隔.
实际上, 我们可以仅仅使用过程来实现序对.

这模糊了我们心中过程和数据之间的界限.
注记: 任何Scheme系统都不会使用这种方式实现序对, 一方面出于效率问题, 另一方面在于我们想要在一般情况下区分序对和过程.
练习. 序对的一项切实的功用是用来返回多个值.

以上过程展现了所谓的"扩展Euclid算法", 试证明它的正确性. 

列表 
[列表] by ultimatelambda

空表是一个列表.

quote形式就像是自然语言中的引用现象, 比如apple是一种水果, 而"apple"由5个字母组成. 对于(quote <datum>)求值得到<datum>.
但是, 读者应该注意到, ()并不是一个合法的句法. 尽管()也不会引起什么歧义, 但是Scheme就被设计成这样了.
quote形式是如此频繁地出现, 以至于存在一种很特殊的句法, 或许应该说这是词法层面的.

'()就相当于(quote ()), 实际上Scheme系统会将前者转换为后者.
对于列表lst和任意的Scheme值x, (cons x lst)也是一个列表, 而且它是将x加入lst的首部的列表.

也就是说, 列表其实就是用序对串在一起的对象, 只不过最后要以空表结尾.
显然, 我们可以用car取得列表的首元素, cdr取得列表除首元素剩余的列表. 将car和cdr应用于空表会引起异常. (另一种Lisp方言Common Lisp中就不会, 而是返回空表.)
Scheme内置的函数list可以用来方便地构造列表.

当然, 使用quote形式更加方便.

但实际上quote形式更加一般, 可以引用各种各样的东西.

这里我们隐式地引入了类型为符号的对象.
显然, 列表可以用来编码各种各样的信息, 比如用来表示程序文本. 将其作为知识表示的手段, 是古典人工智能里最根本性的想法之一. 

利用图像表示序对结构 
[利用图像表示序对的结构] by ultimatelambda

使用图像来表示序对结构 (也常被称为列表结构, 但不一定是列表), 常常有助于理解.



练习. 画出对于以下Scheme表达式求值得到的序对结构的图像.
 

定义于列表上的函数 
[定义于列表上的函数] by ultimatelambda

LISP是LISt Processing的缩写, 这显然暗示了LISP必然包含许多和列表有关的函数, 让我们现在就来检视一些.
最简单的函数大概就是length (尽管一个实际的实现里的length并不会那么简单, 因为它还要考虑"环路"的情况), 它大概可以定义如下.

以下是一些例子.

另外一个很简单的函数是list-ref, 它取出列表某个位置的元素, 以下是一种可能的定义.

然后是一些例子.

现在让我们来引入memq, memv和member, 但首先我们应该讨论一下谓词eq?, eqv?和equal?.
eq?, eqv?和equal?是Scheme中三种不同的判断相等性的谓词. 现在因为读者对于Scheme的理解还不够深入, 即便直截了当地讨论它们的区别, 或许也是没有益处的. 但读者可以这么区分它们, equal?是外延等价的近似物, eq?是内涵等价的近似物, eqv?是用来补充eq?的, 也是内涵等价的近似物. 比如, 请看以下例子.

之所以会出现这样的情况, 是因为每次cons创建的都是"不同"的序对对象.
就此打住.
memq, memv和member仅仅是所用相等谓词不同而已, 其余都是一样的.
一种可能的memq定义如下.

它可以用来判断一个元素是否在列表中, 以下是一些例子.

正如名字所暗示的那样, memq用eq?比较相等, memv用eqv?, member用equal?.
接着, 让我们来看assq, assv和assoc.
在Scheme上下文中, 元素均为序对的列表被称为关联表 (association list), 它可以用来表示对应关系 (的外延).
以下是assq的一种可能定义.

注记.

这也可以类推到c和r之间隔着3个4个a或d的情况. 但是更多, Scheme标准就不保证了.
接下来是一些例子.

也就是说, assq可以根据每个序对的car部分 (一般被称为键) 进行索引.
练习.  编写过程assp, 它接受一个谓词和一个关联表, 然后返回第一个"键满足谓词"的序对, 如果这样的序对不存在, 就返回#f. 以下是一些例子.

symbol?判断一个对象是否是符号, 类似的还有number?, pair?, procedure?等. 

列表处理工具箱 
[列表处理工具箱] by ultimatelambda

不难看出, 列表可以作为表示有限序列的通用媒介.  围绕这一媒介, 我们可以设计一组通用的处理过程. 这些过程可以自由地进行组合, 就像搭积木一样简单.
1. map
最具有代表性的列表处理过程应该就是map了, 它将一个函数应用于列表的每个元素上.
一种可能的map定义如下.

其中null?是一个谓词, 对于空表返回#t, 否则返回#f.
想必读者对于map还不甚熟悉, 让我们来计算一个例子.

2. filter
filter从列表中过滤出满足谓词的元素.
一种可能的filter定义如下.

以下是一些例子.

3. append
append将两个列表连接起来.

注记. 从append的定义可以看出, 其实第二个参数不是列表也可以.
以下是一些例子.

4. reverse
reverse反转一个列表.

以下是一些例子.

注记. reverse当然也可以按照如下方式定义, 就是效率看上去就会很尴尬.

5. fold-left和fold-right
fold-left和fold-right, 在某种程度上说, 提供了对于列表处理过程的抽象.
因为fold-left和fold-right比较复杂, 我们先举例子.


现在我们给出fold-left和fold-right的定义.

为了说明fold-left和fold-right何以为抽象, 我们用它们来重新定义之前的列表处理过程.

练习. 我们给出的fold-right的定义呈现出递归计算行为, 试将其改写为呈现迭代计算行为的版本. 

列表处理工具箱续 
[列表处理工具箱续] by ultimatelambda

在"列表处理工具箱"之基础上, 我们继续来检视一些列表处理的习语.
1. append-map
append-map就类似于map, 它的一种可能定义如下.

与map的定义相比, 其实append-map仅仅是将cons替换成了append.
注记. append-map又常被称为flatmap.
平凡的例子多看无益, 我们看看一个稍不平凡的应用吧.

product产生两个列表的"笛卡尔积", 以下是一些例子.

实际上, 我们可以定义更一般的product.

当然了, 一般的product亦可以借助于fold-right之抽象来定义.

以下是一些例子.

当然了, 上面存在一些留待解释的Scheme机制.
一个是apply函数 (而不是形式), 还是举一些例子说明为好.
(apply + '(1 2 3))就相当于(+ 1 2 3), 所以结果是6.
apply函数也可以接受更多的参数, 比如
(apply + 1 2 '(3))也相当于(+ 1 2 3),
也就是说, 多出来的参数会按照顺序拼接到列表的前段.
另一个则是Scheme用以定义接受多个参数的过程的点记号.
理解点记号的方式在于将其视为"模式匹配", 不过"模式"在形式上非常受限.
比如(product . lst*)和(product)匹配会怎样, 要使得两个项相同, 就必须令lst*是();
(product . lst*)和(product (1 2) (a b))匹配会怎样, 要使得两个项相同, 就必须令lst*是((1 2) (a b)).
所以, product可以接受任意多个参数, 然后这些参数会形成一个列表, 此即lst*绑定至的值.
(define (product . lst*) <body>)应该算是句法糖, 脱糖的写法是
(define product (lambda lst* <body>)).
不过, 同样是按照模式匹配来理解.
同理, (define (foo a . x*) <body>)或等价版本(define foo (lambda (a . x*) <body>))定义了接受大于等于一个参数的过程, 并且第一个参数的值和a相关联, 其后的值形成列表与x*相关联.
(define (bar a b . x*) <body>)或等价版本(define bar (lambda (a b . x*) <body>))呢? 你肯定有答案了.
注记. 我必须承认这里的记号并非一致, 但希望读者能够领会我说的意思, 而不是纠结于细节.
2. 生成列表的过程.
这些过程的构造往往需要ad hoc的智慧, 是依照手头事情的特殊性得来的, 我们只看一个例子.

init代表初值, next代表从一值转移到下一值的过程, pred是判断值是否合乎要求的谓词.
利用enumerate之抽象, 常可定义一些较为实用的过程, 比如iota.

以下是一些例子.

练习. 编写过程foo, 以自然数n为输入, 产生所有满足和小于n的自然数三元组的列表.


节末注记. 对于列表处理, 我们侧重的是我们能够表达什么, 而不是效率事务. (事实上, 许多情况下, 列表处理无可救药地低效.) 在某种意义上, APL语言提供了类似的表达力. 在APL中, 一切都是矩阵, 而有许多用于处理矩阵的函数. APL语言实现的策略是尽可能综合这些函数, 比如合成两个操作为一个. 显然, 我们也可以在Scheme实现中内置这样的优化, 比如合成两趟map为一趟. (但是, 鉴于Scheme的灵活性, 为了保持正确的语义, 优化其实很难进行, 但我想对于受限的应用常能发挥很好的效用.) 

列表处理习题一 
[列表处理习题一] by ultimatelambda




 

列表处理习题二 
[列表处理习题二] by ultimatelambda

本题来源于SICP.

 

列表处理习题三 
[列表处理习题三] by ultimatelambda







暂且就这么多吧. 

第三章 状态和对象
赋值和变动 
[赋值和变动] by ultimatelambda





 

闭包和对象 
[闭包和对象] by ultimatelambda

我们从一个例子开始.

像counter这样的过程被有的人称之为let over lambda, 甚至有一本书以此为标题. 有的人喜欢称counter这样的过程为闭包, 但是实际上在概念上每个Scheme过程都是闭包. 有的人可能反对我的说法, 因为他们将闭包视为特定的实现技术, 但是那的确也是从概念上理解Scheme过程的正当做法.
一个闭包由过程的代码和创建过程所在的环境组成. 没有更多了. 这个名字理解起来是十分简单的, 也就是说, 过程的代码本身可能不是封闭的, 因为其可能含有自由变量, 但是通过将创建过程所在的环境容纳于考虑的范围之内, 过程就成为了封闭形式. 显然, 在实际的实现中, 并不需要保存整个环境, 只需要保存自由变量就够了.
counter见过以后, 让我们看看它的亲戚make-counter.

像make-counter这样的过程也被称为lambda over let over lambda, 原因也是显然的. 在对于(make-counter)求值时, x和0之间的绑定先被创建, 但是每次求值时的绑定也是不同的, 所以由make-counter创建的不同的counter之间不会相互干扰.
let over lambda式的过程常被称为「对象」, 这里的对象应该理解为带有局部状态的过程, 而且这个对象也与面向对象中的对象有关, 正所谓「闭包是穷人的对象, 对象是穷人的闭包」. 至于面向对象的本体论问题, 这不在我们书中交代. 对于Lisper/Schemer而言, 另一个重要的观念是对象之间通过「消息」进行交互, 我们之后再说. 

消息传递 
[消息传递] by ultimatelambda

在整本书中, 基本上我们都将消息表示为符号. 另外, 现在我们新的句法结构case.

它就等价于

else不是必须的, 但若出现只能出现在最后一行.
在某些实现中, 相等也可能使用equal?进行判断.
基本上我们使用case时<datum>只可能是符号.
让我们通过几个例子来熟悉case和消息传递.
第一个例子是counter的变种.

新的counter具有几种不同的机能, 当收到消息add1!时, 它计上一; 当收到消息init!时, 它重置计数; 当收到消息x时, 它反馈当前统计.
第二个例子是栈, 栈是一种「先进后出」的数据结构. 从现在开始, 我们将引入数据抽象和数据结构的概念.
提到数据抽象, 就不得不提到抽象数据类型. 抽象数据类型是由一系列创建, 解构, 操作数据的过程和它们所满足的约束定义的. 这就在数据及其具体实现之间建立了抽象边界. 如果一个程序使用抽象数据类型, 但不依赖于任何的实现细节, 我们就称这个程序尊重抽象边界. 尊重抽象边界的程序可以换用不同的实现而不会影响其机能, 这也是经常的事情, 尤其是在原型设计时. Scheme本身没有提供什么强制执行抽象边界的机制, 但是的确也有一些常见的方法. 不过, 在本书中, 我们完全不关心这点, 我们只希望读者理解抽象数据类型是什么而已.
数据结构则是一个多义词, 它可以指
1.  一个抽象数据类型;
2.  一个抽象的一个具体实现;
3.  一个实现的一个实例;
4.  一种特定的数据的物理表示.
对于作为抽象数据类型的栈而言, 最重要的操作是push!和pop!, push!压入一个元素进栈, pop!从栈中弹出一个元素. 另外重要的可能是判断栈是否为空的谓词empty-stack?.
现在我们给出一个简单的实现.

以下是例子.

注记1. 我们可以编写几个额外的过程.

这只是风格上的不同, 消息传递风格vs传统过程调用风格.
注记2. 当然, 我们还可以更简单一点.

不过, 如果需要栈的多个实例, 这么做就不方便了.
注记3. 消息传递风格当然也可能有不同的变种, 比如以下的版本.

这样的话, 每个栈对象接受消息之后, 得到的是「方法」 (面向对象的术语). 这么做的好处, 虽然这个例子里面完全没有用, 其中一个是可以引用对象自身. 当然, 我们需要一个辅助过程来调用方法.

我必须要说, 这些东西完全不是我的创制, 而是长久流传于Scheme程序员间的一些习语. 它们可以ad hoc地运用一些面向对象的机制, 但是我要说在Scheme中嵌入一个CLOS (Common Lisp Object System) 式的面向对象系统要比人们想象中的可能要容易得多, 不过这也不在本书中交代.
练习. 给我们的实现添加一些机能, 比如对于最大栈深度和当前栈深度的统计.
练习. 我们的实现基于列表, 另一种典型的实现基于向量, 请读者完成这个实现.
现在让我们引入向量, 在某种意义上它类似于列表, 可以用来表示有限序列.
过程vector, 类似于list, 可以创建向量.

过程vector-ref, 类似于list-ref, 可以取得向量的分量.

过程vector-length, 类似于length, 可以取得向量的长度.

vector-set!, 类似于list-set!, 可以修改向量的分量. (好吧, 我还没提过list-set!. 不过, 一般没有人使用这个过程.)

练习. 编制过程list-set!.
过程vector?判断一个值是否是向量.

向量和列表的不同在于向量是随机可达的, 但列表不是. 回想一下list-ref的定义, 它需要经过许多序对才能到达目标, 而且这个序对的数目是由分量的位置决定的, 当然list-set!也是如此. 但是vector-ref和vector-set!不同, 它们可以在很短的常量时间内完成, 因为从计算机器的实现来说, 当你知道向量对象在什么位置的时候, 就可以直接计算出它每个分量的位置, 但是列表不行, 因为列表是由序对串在一起的.
练习. 实现队列, 一种「先进先出」的数据结构. 

编程语言的邀请
前言 
[编程语言的邀请 0 前言] by ultimatelambda

我一直有写一本编程语言导引的打算, 但是这个打算最多也只能算是部分完成了. 而且, 仅考虑完成的部分, 也不能令我满意, 毕竟它似乎对于不懂编程语言的人没有任何的吸引力. 诚然, 我也有些过于理想化了, 毕竟我回答不了"为什么要学习编程语言"这种问题.
我希望对于编程语言感兴趣的初中生高中生可以读读我写的材料. 至于大学生, 那还是读读Types and Programming Languages这种标准教材吧.
我们介绍编程语言的方法可以追溯至John McCarthy为了刻画Lisp的威力而编写的元解释器 (Lisp写的Lisp解释器). 一个解释器以程序文本 (的表示) 为输入, 以值为输出, 因而它可以被视为对于其所解释的语言的语义的描述. 这种方法所遇到的根本困难在于为了刻画某个编程语言的语义, 首先要刻画编写解释器所用的语言的语义. 我们没有为这个困难而烦扰, 因为我们依赖于读者对于语义的直觉. 自始至终, 我们都使用Scheme来编制程序, Scheme是Lisp的主要方言之一, 选择它的原因不过是因为用所谓的符号表达式表示抽象句法树很方便罢了.
我们的解释器在风格上近于大步操作语义, 或者说自然操作语义, 而不是小步操作语义. 我们很少证明关于程序的性质, 而是强调读者首先应该先从直觉上进行理解, 这对于以后严肃的学习完全是必要的. 

句法 
[编程语言的邀请 1 句法] by ultimatelambda


以下内容均使用了Texmacs进行排版. Texmacs是一个很有意思的东西, 它的排版算法吸收了Tex的经验, 但是文档却是结构化的. 操作上则借鉴了Emacs, 可以通过Scheme进行扩展.




 

绑定 
[编程语言的邀请 2 绑定] by ultimatelambda



 

过程第一部分 
[编程语言的邀请 3 过程 (第一部分)] by ultimatelambda






 

过程第二部分 
[编程语言的邀请 3 过程 (第二部分)] by ultimatelambda








 

过程第三部分 
[编程语言的邀请 3 过程 (第三部分)] by ultimatelambda






 

过程第四部分 
[编程语言的邀请 3 过程 (第四部分)] by ultimatelambda






 

编程语言的邀请遗弃版
编程语言的邀请12 
[编程语言的邀请12] by ultimatelambda


 

编程语言的邀请13 
[编程语言的邀请13] by ultimatelambda





 

编程语言的邀请14 
[编程语言的邀请14] by ultimatelambda







 

编程语言的邀请15 
[编程语言的邀请15] by ultimatelambda


 

编程语言的邀请18 
[编程语言的邀请18] by ultimatelambda




 

编程语言的邀请19 
[编程语言的邀请19] by ultimatelambda





 

编程语言的邀请20 
[编程语言的邀请20] by ultimatelambda






 

古典人工智能的邀请
古典人工智能的邀请0 模式匹配 
[古典人工智能的邀请0 模式匹配] by ultimatelambda

这些内容并非标准, 只反映了作者的个人见解.
古典人工智能是研究如何使用编程语言表达人类对于自身思考过程的高层次描述的领域. 也就是说, 它不是数学, 逻辑, 算法的附庸, 尽管它可能与这些学科有着紧密的联系. 对于编程语言的研究在古典人工智能中处于核心地位, 因为本质上古典人工智能的问题是表达力的问题. 而且, 从历史看来, 古典人工智能尤其偏爱Lisp族语言, 这很大程度上是因为其灵活性, 尤其是作为通用媒介的符号表达式 (S-exp, S-expression, symbolic expression) 的灵活性. 这使得在Lisp中嵌入语言自然而流畅.
在古典人工智能中首先发展起来的是模式匹配和基于规则的程序, 这是因为很大程度上人类的知识也是基于模式编码的. 比如modus ponens指的是如果有了P和P->Q, 就可以断言Q. 这里的P和Q是元语言的变量, 如果将其一致地替换为对象语言的句子, 就能得到modus ponens的实例. 但是使用modus ponens时, 人类并不预先知道要运用其怎样的实例, 而实际上是通过模式匹配提取出潜在的可能性, 即P和Q是什么的时候可以运用modus ponens.
另一个典型的例子是符号微分, 它也是John McCarthy设计Lisp的初衷之一, 以下是一个具体的Scheme程序.

以下是一些例子.

这个简短的程序只处理由数字, 变量, 加法, 乘法任意复合的表达式的符号微分, 但已经充分说明了问题. match是一个模式匹配的宏, 它用以解构表达式 (或者说句法树). 实际上, 该程序不过是微分法则的直接翻译而已. Alan Perlis说过一句名言, A programming language is low level when its programs require attention to the irrelevant. 古典人工智能的终极目标正是以直接的方式表达一切人类所需要表达的想法和概念, 不论其是否和计算有关.
或许一个显而易见的问题是为什么要使用编程语言进行表达. 对于作者而言, 编程语言是一种精确媒介. 在使用编程语言进行表达的过程中, 一切思维中错误和不准确的地方很容易被发现. 这对于让别人理解自己的想法也是好的. 事实上, 在数学和物理的表述中, 已经有太多不准确的地方了, 它们已经对于许多人造成了不可挽回的伤害. 

附余
编程语言书籍推荐 
[编程语言书籍推荐] by ultimatelambda

感觉最近要忙于学习, 暂不更新. 对于有志于研究编程语言者, 我推荐下列书籍.
程序设计入门
1. Structure and Interpretation of Computer Programs
虽老但好, 不减当年风采. 通过阅读此书, 读者可期对于计算机整体拥有全面深入的了解.
(有中文翻译, 但文学性部分翻译全是错的, 技术性部分却没有太大问题.)
2. The Little Schemer; The Seasoned Schemer
采用对话体写成, 饶富趣味. 有些内容相当值得一读, 比如对于应用序y算子的推导.
(The Little Schemer最近也有中文译本了.)
3. How to Design Programs
较新的书, 带有现代美式计算机教材特有的啰嗦, 但是内容没有什么问题, 甚至涵盖了前面书中没讲但重要的东西, 即便读者可以从其他地方学到.
(有第一版的中文翻译, 但第二版没有.)
4. Programming in Standard ML
虽然没有写完, 但已经写了的部分可以读一读. Standard ML是编程语言人的智慧结晶, 从中可以学到许多.
(没有中文翻译.)
编程语言入门
1. Essentials of Programming Languages
较为浅易, 几乎没有任何定理和证明, 适合非常不擅长数学的人阅读, 或是作为初次学习编程语言获得对于其大概的直觉印象.
(没有中文翻译, 我自己翻译了一小部分.)
2. Programming Languages: Application and Interpretation
可以看作是受到EoPL启发而产生的书籍, 比EoPL更为现代, 内容更为丰富.
(有还算可以的中文翻译.)
3. Types and Programming Languages
凡治编程语言者, 无不听闻其大名. 这本书就是如此重要, 任何学习编程语言的人都不应该错过. 而且, 这本书不难.
(有中文翻译, 但还不如没有.)
4. Practical Foundations for Programming Languages
Robert Harper的专著, 对于编程语言的百科全书式处理, 强烈地反映了其个人的见解.
(没有中文翻译.)
5. Semantics Engineering with PLT Redex
欲对于抽象机器有所了解, 应阅读第一部分, 而第二部分是对于第一部分内容的程序化机械化处理. 第三部分可不读, 因为是第二部分引入的工具的应用.
(没有中文翻译.)
6. Software Foundations第一卷和第二卷
使用证明助手Coq对于逻辑和编程语言的介绍.
(有中文翻译.)
7. Programming Language Foundations in Agda
Software Foundations的第二卷的Agda版本
(有中文翻译.)
8. Proofs and Types
本书更偏向逻辑学一些, 但本来逻辑学和编程语言就不分家, 一部分原因是Curry-Howard同构.
(没有中文翻译.)
可计算性与计算复杂度
1. Computability and Complexity (Neil Jones)
本书是一本奇书, 将编程语言人的观念引入可计算性与计算复杂度理论中.
(没有中文翻译.)
部分求值
1. Partial Evaluation and Automatic Program Generation
部分求值其实就是程序特化, 就是固定什么参数不变.
(没有中文翻译.)

好了, 先就这么多吧. 

